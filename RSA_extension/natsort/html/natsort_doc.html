
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>NATSORT Examples</title><meta name="generator" content="MATLAB 8.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-09-26"><meta name="DC.source" content="natsort_doc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>NATSORT Examples</h1><!--introduction--><p>The function <a href="https://www.mathworks.com/matlabcentral/fileexchange/34464"><tt>NATSORT</tt></a> sorts a cell array of strings (1xN char), taking into account any number values within the strings. This is known as a <i>natural order sort</i> or an <i>alphanumeric sort</i>. Note that MATLAB's inbuilt <a href="https://www.mathworks.com/help/matlab/ref/sort.html"><tt>SORT</tt></a> function sorts only by character order, as does <tt>SORT</tt> in most programming languages.</p><p>For sorting filenames or filepaths use <a href="https://www.mathworks.com/matlabcentral/fileexchange/47434"><tt>NATSORTFILES</tt></a>.</p><p>For sorting the rows of a cell array of strings use <a href="https://www.mathworks.com/matlabcentral/fileexchange/47433"><tt>NATSORTROWS</tt></a>.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Basic Usage: Integer Numbers</a></li><li><a href="#2">Output 2: Sort Index</a></li><li><a href="#3">Output 3: Debugging Array</a></li><li><a href="#4">Input 2: Regular Expression</a></li><li><a href="#5">Input 3+: Case Sensitivity</a></li><li><a href="#6">Input 3+: Sort Direction</a></li><li><a href="#7">Input 3+: Char/Number Order</a></li><li><a href="#8">Input 3+: NaN/Number Order</a></li><li><a href="#9">Input 3+: <tt>SSCANF</tt> Format String (Floating Point, Hexadecimal, Octal, Binary, 64 Bit Integer)</a></li><li><a href="#10">Regular Expression: Decimal Fractions, E-notation, +/- Sign</a></li><li><a href="#11">Regular Expression: Hexadecimal, Octal, Binary Integers</a></li><li><a href="#12">Bonus: Interactive Regular Expression Tool</a></li></ul></div><h2>Basic Usage: Integer Numbers<a name="1"></a></h2><p>By default <tt>NATSORT</tt> interprets consecutive digits as being part of a single integer, any remaining substring/s are treated as character:</p><pre class="codeinput">A = {<span class="string">'a2'</span>, <span class="string">'a10'</span>, <span class="string">'a1'</span>};
sort(A)
natsort(A)
B = {<span class="string">'ver9.10'</span>, <span class="string">'ver9.5'</span>, <span class="string">'ver9.2'</span>, <span class="string">'ver9.10.20'</span>, <span class="string">'ver9.10.8'</span>};
sort(B)
natsort(B)
</pre><pre class="codeoutput">ans = 
    'a1'    'a10'    'a2'
ans = 
    'a1'    'a2'    'a10'
ans = 
    'ver9.10'    'ver9.10.20'    'ver9.10.8'    'ver9.2'    'ver9.5'
ans = 
    'ver9.2'    'ver9.5'    'ver9.10'    'ver9.10.8'    'ver9.10.20'
</pre><h2>Output 2: Sort Index<a name="2"></a></h2><p>The second output argument is a numeric array of the sort indices <tt>ndx</tt>, such that <tt>Y = X(ndx)</tt> where <tt>Y = natsort(X)</tt>:</p><pre class="codeinput">[~,ndx] = natsort(A)
</pre><pre class="codeoutput">ndx =
     3     1     2
</pre><h2>Output 3: Debugging Array<a name="3"></a></h2><p>The third output is a cell array which contains all matched numbers (after converting to numeric using the specified <tt>SSCANF</tt> format) and all split character substrings. This cell array is useful for confirming that the numbers are being correctly identified by the regular expression. Note that the rows of the debugging cell array are <a href="https://www.mathworks.com/company/newsletters/articles/matrix-indexing-in-matlab.html">linearly indexed</a> from the input cell array, the even columns contain any matched number values, while the odd columns contain any split substrings:</p><pre class="codeinput">[~,~,dbg] = natsort(B)
</pre><pre class="codeoutput">dbg = 
    'ver'    [9]    '.'    [10]    ''     ''  
    'ver'    [9]    '.'    [ 5]    ''     ''  
    'ver'    [9]    '.'    [ 2]    ''     ''  
    'ver'    [9]    '.'    [10]    '.'    [20]
    'ver'    [9]    '.'    [10]    '.'    [ 8]
</pre><h2>Input 2: Regular Expression<a name="4"></a></h2><p>The optional second input argument is a regular expression which specifies the number matching:</p><pre class="codeinput">C = {<span class="string">'1.3'</span>,<span class="string">'1.10'</span>,<span class="string">'1.2'</span>};
natsort(C)   <span class="comment">% by default match integers</span>
natsort(C, <span class="string">'\d+\.?\d*'</span>) <span class="comment">% match decimal fractions</span>
</pre><pre class="codeoutput">ans = 
    '1.2'    '1.3'    '1.10'
ans = 
    '1.10'    '1.2'    '1.3'
</pre><h2>Input 3+: Case Sensitivity<a name="5"></a></h2><p>By default <tt>NATSORT</tt> provides a case-insensitive sort of the input strings. An optional input argument selects case-sensitive/insensitive sorting:</p><pre class="codeinput">D = {<span class="string">'a2'</span>, <span class="string">'A20'</span>, <span class="string">'A1'</span>, <span class="string">'a'</span>, <span class="string">'A'</span>, <span class="string">'a10'</span>,<span class="string">'A2'</span>, <span class="string">'a1'</span>};
natsort(D, [], <span class="string">'ignorecase'</span>) <span class="comment">% default</span>
natsort(D, [], <span class="string">'matchcase'</span>)
</pre><pre class="codeoutput">ans = 
    'a'    'A'    'A1'    'a1'    'a2'    'A2'    'a10'    'A20'
ans = 
    'A'    'A1'    'A2'    'A20'    'a'    'a1'    'a2'    'a10'
</pre><h2>Input 3+: Sort Direction<a name="6"></a></h2><p>By default <tt>NATSORT</tt> provides an ascending sort of the input strings. An optional input argument selects the sort direction (note that characters and numbers are either both ascending or both descending):</p><pre class="codeinput">E = {<span class="string">'2'</span>, <span class="string">'a'</span>, <span class="string">''</span>, <span class="string">'10'</span>, <span class="string">'B'</span>, <span class="string">'1'</span>};
natsort(E, [], <span class="string">'ascend'</span>) <span class="comment">% default</span>
natsort(E, [], <span class="string">'descend'</span>)
</pre><pre class="codeoutput">ans = 
    ''    '1'    '2'    '10'    'a'    'B'
ans = 
    'B'    'a'    '10'    '2'    '1'    ''
</pre><h2>Input 3+: Char/Number Order<a name="7"></a></h2><p>By default <tt>NATSORT</tt> sorts characters after numbers. An optional input argument selects if characters are treated as <i>greater-than</i> or <i>less-than</i> numbers:</p><pre class="codeinput">natsort(E, [], <span class="string">'num&lt;char'</span>) <span class="comment">% default</span>
natsort(E, [], <span class="string">'char&lt;num'</span>)
</pre><pre class="codeoutput">ans = 
    ''    '1'    '2'    '10'    'a'    'B'
ans = 
    ''    'a'    'B'    '1'    '2'    '10'
</pre><h2>Input 3+: NaN/Number Order<a name="8"></a></h2><p>By default <tt>NATSORT</tt> sorts NaN after all other numbers. An optional input argument selects if NaN are treated as <i>greater-than</i> or <i>less-than</i> numbers:</p><pre class="codeinput">F = {<span class="string">'10'</span>, <span class="string">'1'</span>, <span class="string">'NaN'</span>, <span class="string">'2'</span>};
natsort(F, <span class="string">'(NaN|\d+)'</span>, <span class="string">'num&lt;NaN'</span>) <span class="comment">% default</span>
natsort(F, <span class="string">'(NaN|\d+)'</span>, <span class="string">'NaN&lt;num'</span>)
</pre><pre class="codeoutput">ans = 
    '1'    '2'    '10'    'NaN'
ans = 
    'NaN'    '1'    '2'    '10'
</pre><h2>Input 3+: <tt>SSCANF</tt> Format String (Floating Point, Hexadecimal, Octal, Binary, 64 Bit Integer)<a name="9"></a></h2><p>The default format string <tt>'%f'</tt> will correctly parse many common number types: this includes decimal integers, decimal fractions, <tt>NaN</tt>, <tt>Inf</tt>, and numbers written in E-notation. For hexadecimal, octal, binary, and 64-bit integers the format string must be specified as an input argument. Supported <a href="https://www.mathworks.com/help/matlab/ref/sscanf.html"><tt>SSCANF</tt></a> formats are shown in this table:</p><p>
<table>
 <tr><th>Format String</th><th>Number Types</th></tr>
 <tr><td>%e, %f, %g</td>   <td>floating point numbers</td></tr>
 <tr><td>%d</td>           <td>signed decimal</td></tr>
 <tr><td>%i</td>           <td>signed decimal, octal, or hexadecimal</td></tr>
 <tr><td>%ld, %li</td>     <td>signed 64 bit, decimal, octal, or hexadecimal</td></tr>
 <tr><td>%u</td>           <td>unsigned decimal</td></tr>
 <tr><td>%o</td>           <td>unsigned octal</td></tr>
 <tr><td>%x</td>           <td>unsigned hexadecimal</td></tr>
 <tr><td>%lu, %lo, %lx</td><td>unsigned 64-bit decimal, octal, or hexadecimal</td></tr>
 <tr><td>%b</td>           <td>unsigned binary integer (custom parsing, not SSCANF)</td></tr>
</table>
</p><p>For example large integers can be converted to 64-bit numerics, with their full precision:</p><pre class="codeinput">natsort({<span class="string">'18446744073709551614'</span>, <span class="string">'18446744073709551615'</span>, <span class="string">'18446744073709551613'</span>}, [], <span class="string">'%lu'</span>)
</pre><pre class="codeoutput">ans = 
    '18446744073709551613'    '18446744073709551614'    '18446744073709551615'
</pre><h2>Regular Expression: Decimal Fractions, E-notation, +/- Sign<a name="10"></a></h2><p><tt>NATSORT</tt> relies on <a href="https://www.mathworks.com/help/matlab/ref/regexpi.html"><tt>REGEXPI</tt></a> to detect numbers in the strings. In order to match the required number format (e.g. decimal fractions, exponents, or a positive/negative sign, etc.) simply provide a suitable <a href="https://www.mathworks.com/help/matlab/matlab_prog/regular-expressions.html">regular expression</a> as an optional input argument:</p><pre class="codeinput">G = {<span class="string">'x+NaN'</span>, <span class="string">'x11.5'</span>, <span class="string">'x-1.4'</span>, <span class="string">'x'</span>, <span class="string">'x-Inf'</span>, <span class="string">'x+0.3'</span>};
sort(G)
natsort(G, <span class="string">'[-+]?(NaN|Inf|\d+\.?\d*)'</span>)
H = {<span class="string">'0.56e007'</span>, <span class="string">''</span>, <span class="string">'43E-2'</span>, <span class="string">'10000'</span>, <span class="string">'9.8'</span>};
sort(H)
natsort(H, <span class="string">'\d+\.?\d*([eE][-+]?\d+)?'</span>)
</pre><pre class="codeoutput">ans = 
    'x'    'x+0.3'    'x+NaN'    'x-1.4'    'x-Inf'    'x11.5'
ans = 
    'x'    'x-Inf'    'x-1.4'    'x+0.3'    'x11.5'    'x+NaN'
ans = 
    ''    '0.56e007'    '10000'    '43E-2'    '9.8'
ans = 
    ''    '43E-2'    '9.8'    '10000'    '0.56e007'
</pre><h2>Regular Expression: Hexadecimal, Octal, Binary Integers<a name="11"></a></h2><p>Integers encoded in hexadecimal, octal, or binary may also be parsed and sorted correctly. This requires both an appropriate regular expression that can detect the integers correctly and also a suitable <tt>SSCANF</tt> format string for converting the detected number string into numeric:</p><pre class="codeinput">I = {<span class="string">'a0X7C4z'</span>, <span class="string">'a0X5z'</span>, <span class="string">'a0X18z'</span>, <span class="string">'a0XFz'</span>};
sort(I)
natsort(I, <span class="string">'0X[0-9A-F]+'</span>, <span class="string">'%x'</span>) <span class="comment">% hexadecimal</span>
J = {<span class="string">'a11111000100z'</span>, <span class="string">'a101z'</span>, <span class="string">'a000000000011000z'</span>, <span class="string">'a1111z'</span>};
sort(J)
natsort(J, <span class="string">'[01]+'</span>, <span class="string">'%b'</span>) <span class="comment">% binary</span>
</pre><pre class="codeoutput">ans = 
    'a0X18z'    'a0X5z'    'a0X7C4z'    'a0XFz'
ans = 
    'a0X5z'    'a0XFz'    'a0X18z'    'a0X7C4z'
ans = 
    'a000000000011000z'    'a101z'    'a11111000100z'    'a1111z'
ans = 
    'a101z'    'a1111z'    'a000000000011000z'    'a11111000100z'
</pre><h2>Bonus: Interactive Regular Expression Tool<a name="12"></a></h2><p>Regular expressions are powerful and compact, but getting them right is not always easy. One assistance is to download my interactive tool <a href="https://www.mathworks.com/matlabcentral/fileexchange/48930"><tt>IREGEXP</tt></a>, which lets you quickly try different regular expressions and see all of <a href="https://www.mathworks.com/help/matlab/ref/regexp.html"><tt>REGEXP</tt></a>'s outputs displayed and updated as you type.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2012b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% NATSORT Examples
% The function <https://www.mathworks.com/matlabcentral/fileexchange/34464
% |NATSORT|> sorts a cell array of strings (1xN char), taking into account
% any number values within the strings. This is known as a _natural order
% sort_ or an _alphanumeric sort_. Note that MATLAB's inbuilt
% <https://www.mathworks.com/help/matlab/ref/sort.html |SORT|> function sorts
% only by character order, as does |SORT| in most programming languages.
%
% For sorting filenames or filepaths use
% <https://www.mathworks.com/matlabcentral/fileexchange/47434 |NATSORTFILES|>.
%
% For sorting the rows of a cell array of strings use
% <https://www.mathworks.com/matlabcentral/fileexchange/47433 |NATSORTROWS|>.
%
%% Basic Usage: Integer Numbers
% By default |NATSORT| interprets consecutive digits as being part of a
% single integer, any remaining substring/s are treated as character:
A = {'a2', 'a10', 'a1'};
sort(A)
natsort(A)
B = {'ver9.10', 'ver9.5', 'ver9.2', 'ver9.10.20', 'ver9.10.8'};
sort(B)
natsort(B)
%% Output 2: Sort Index
% The second output argument is a numeric array of the sort indices |ndx|,
% such that |Y = X(ndx)| where |Y = natsort(X)|:
[~,ndx] = natsort(A)
%% Output 3: Debugging Array
% The third output is a cell array which contains all matched numbers
% (after converting to numeric using the specified |SSCANF| format) and
% all split character substrings. This cell array is useful for
% confirming that the numbers are being correctly identified by the
% regular expression. Note that the rows of the debugging cell array are
% <https://www.mathworks.com/company/newsletters/articles/matrix-indexing-in-matlab.html
% linearly indexed> from the input cell array, the even columns contain any
% matched number values, while the odd columns contain any split substrings:
[~,~,dbg] = natsort(B)
%% Input 2: Regular Expression
% The optional second input argument is a regular expression which
% specifies the number matching:
C = {'1.3','1.10','1.2'};
natsort(C)   % by default match integers
natsort(C, '\d+\.?\d*') % match decimal fractions
%% Input 3+: Case Sensitivity
% By default |NATSORT| provides a case-insensitive sort of the input strings.
% An optional input argument selects case-sensitive/insensitive sorting:
D = {'a2', 'A20', 'A1', 'a', 'A', 'a10','A2', 'a1'};
natsort(D, [], 'ignorecase') % default
natsort(D, [], 'matchcase')
%% Input 3+: Sort Direction
% By default |NATSORT| provides an ascending sort of the input strings.
% An optional input argument selects the sort direction (note that
% characters and numbers are either both ascending or both descending):
E = {'2', 'a', '', '10', 'B', '1'};
natsort(E, [], 'ascend') % default
natsort(E, [], 'descend')
%% Input 3+: Char/Number Order
% By default |NATSORT| sorts characters after numbers.
% An optional input argument selects if characters are treated as
% _greater-than_ or _less-than_ numbers:
natsort(E, [], 'num<char') % default
natsort(E, [], 'char<num')
%% Input 3+: NaN/Number Order
% By default |NATSORT| sorts NaN after all other numbers.
% An optional input argument selects if NaN are treated as
% _greater-than_ or _less-than_ numbers:
F = {'10', '1', 'NaN', '2'};
natsort(F, '(NaN|\d+)', 'num<NaN') % default
natsort(F, '(NaN|\d+)', 'NaN<num')
%% Input 3+: |SSCANF| Format String (Floating Point, Hexadecimal, Octal, Binary, 64 Bit Integer)
% The default format string |'%f'| will correctly parse many common number
% types: this includes decimal integers, decimal fractions, |NaN|, |Inf|,
% and numbers written in E-notation. For hexadecimal, octal, binary, and
% 64-bit integers the format string must be specified as an input argument.
% Supported <https://www.mathworks.com/help/matlab/ref/sscanf.html
% |SSCANF|> formats are shown in this table:
%
% <html>
% <table>
%  <tr><th>Format String</th><th>Number Types</th></tr>
%  <tr><td>%e, %f, %g</td>   <td>floating point numbers</td></tr>
%  <tr><td>%d</td>           <td>signed decimal</td></tr>
%  <tr><td>%i</td>           <td>signed decimal, octal, or hexadecimal</td></tr>
%  <tr><td>%ld, %li</td>     <td>signed 64 bit, decimal, octal, or hexadecimal</td></tr>
%  <tr><td>%u</td>           <td>unsigned decimal</td></tr>
%  <tr><td>%o</td>           <td>unsigned octal</td></tr>
%  <tr><td>%x</td>           <td>unsigned hexadecimal</td></tr>
%  <tr><td>%lu, %lo, %lx</td><td>unsigned 64-bit decimal, octal, or hexadecimal</td></tr>
%  <tr><td>%b</td>           <td>unsigned binary integer (custom parsing, not SSCANF)</td></tr>
% </table>
% </html>
%
% For example large
% integers can be converted to 64-bit numerics, with their full precision:
natsort({'18446744073709551614', '18446744073709551615', '18446744073709551613'}, [], '%lu')
%% Regular Expression: Decimal Fractions, E-notation, +/- Sign
% |NATSORT| relies on <https://www.mathworks.com/help/matlab/ref/regexpi.html
% |REGEXPI|> to detect numbers in the strings. In order to match
% the required number format (e.g. decimal fractions, exponents,
% or a positive/negative sign, etc.) simply provide a suitable
% <https://www.mathworks.com/help/matlab/matlab_prog/regular-expressions.html
% regular expression> as an optional input argument:
G = {'x+NaN', 'x11.5', 'x-1.4', 'x', 'x-Inf', 'x+0.3'};
sort(G)
natsort(G, '[-+]?(NaN|Inf|\d+\.?\d*)')
H = {'0.56e007', '', '43E-2', '10000', '9.8'};
sort(H)
natsort(H, '\d+\.?\d*([eE][-+]?\d+)?')
%% Regular Expression: Hexadecimal, Octal, Binary Integers
% Integers encoded in hexadecimal, octal, or binary may also be parsed and
% sorted correctly. This requires both an appropriate regular expression
% that can detect the integers correctly and also a suitable |SSCANF|
% format string for converting the detected number string into numeric:
I = {'a0X7C4z', 'a0X5z', 'a0X18z', 'a0XFz'};
sort(I)
natsort(I, '0X[0-9A-F]+', '%x') % hexadecimal
J = {'a11111000100z', 'a101z', 'a000000000011000z', 'a1111z'};
sort(J)
natsort(J, '[01]+', '%b') % binary
%% Bonus: Interactive Regular Expression Tool
% Regular expressions are powerful and compact, but getting them right is
% not always easy. One assistance is to download my interactive tool
% <https://www.mathworks.com/matlabcentral/fileexchange/48930 |IREGEXP|>,
% which lets you quickly try different regular expressions and see all of
% <https://www.mathworks.com/help/matlab/ref/regexp.html |REGEXP|>'s
% outputs displayed and updated as you type.
##### SOURCE END #####
--></body></html>